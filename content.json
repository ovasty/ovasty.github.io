{"pages":[{"title":"about","text":"关于记录 让思绪延续","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"SEO 添加title与alt 1{% asset_img hello-world.png &quot;title string 'alt string'&quot; %} Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 插件hexo-baidu-url-submit hexo-deployer-git hexo-generator-seo-friendly-sitemap","link":"/posts/helloworld.html"},{"title":"mixpanel系统架构（译）","text":"作者：Vijay Jayaram 时间：June 2018 译者：ovasty 介绍Mixpanel是一个用户分析平台，它让任何人都可以从数据中学习并采取行动。它从遍布全世界的客户的网站和移动App中获取数据并通过可交互的用户界面生成汇总的报告。为了能够提供一个强有力的，支持大规模用户分析的工具，我们花费了数年时间搭建自已的数据库，名叫Arb。在这篇文章中，我们将深入系统架构之中，一探究竟。 我们内部开发了Arb来满足自身严苛的需求： 以用户为中心：Arb是一个定制开发的数据库，为了满足复杂的以用户为中心的查询请求 速度：多数的查询响应时间都少于1秒 实时：采集的数据在1分钟之内即可被查询 可扩展：我们每天采集TB规模的数据，单个查询通常扫描100GB。我们使用Google Cloud，可以进行有效的扩展以满足客户的需求。 相关数字： Mixpanel一年接收超过8万亿条的新数据 Mixpanel的查询引擎每天处理20,000TB的数据以及超过数百万次的查询 Mixpanel的存储系统存储了超过1PB的压缩数据 包括采集与查询处理，系统的稳定运行时间超过99.99% Mixpanel符合SOC2，ISO27001数据中心，GDPR和EU Privacy Shield标准，同时也符合PCI DSS和HIPAA的规范 Mixpanel的架构可以分为3个主要的部分： 数据摄取：接收客户产品发送的数据，并将其进行存储 数据存储：提供了一个分布式、可复制，列式的数据存储 数据查询：接收客户的查询，返回聚合的、可视化的数据 接下来我们会按顺序介绍相关的组件。对于其它一些组件，诸如消息处理、A/B测试以及机器学习等，我们会在以后的文档中再进行介绍。 用户为中心的数据模型Mixpanel数据模型的设计，围绕着如何理解客户产品中的用户行为。客户会发送数据到Mixpanel的项目中。每条数据包括事件（Event）或用户（user）的信息。当用户在产品上进行一个操作时，客户会发送一条事件数据。当获取用户的新信息时，会发送或更新用户的数据，比如注册。图2显示了一个样例项目的数据。 事件Event数据： TIMESTAMP USERID EVENT OS NAME ITEM 2016-12-15T08:02 qrt-345 Browse iPhone raincoat 2016-12-15T08:05 qrt-345 Signup iPhone Janet 2016-12-15T08:07 pnm-321 AddToCart Android popcorn 2016-12-15T08:10 Janet AddToCart iPhone raincoat 2016-12-15T08:10 Vijay AddToCart iPhone chocolate 2016-12-15T08:15 Janet Checkout iPhone 人People数据： USERID EMAIL COUNTRY PHONE FIRST PURCHASE DATE NUMBER OF PURCHASES Janet janet@mixpanel.com US 650-555-1234 2016-12-15 1 Vijay vijay@dogsrus.nl NL 2016-02-19 7 Jessica jw@gogogo.com US 914-555-5678 2015-07-29 12 别名Alias数据： NAMED_USERID (ALIAS) ORIGINAL_USERID Jessica abc-123 Jessica azy-456 Janet qrt-345 Vijay xyz-789 mixpanel schemaMixpanel的数据模型由事件和人的表组成。 Event表记录用户的行为数据。包括： timestamp：时间戳，用户何时进行的操作 identifier：用户识别符，记录谁执行了操作 event name：事件名称，做了什么操作 properties：属性，描述事件的更多信息，如对于“购买”事件描述具体购买的商品 People表记录用户。包括： identifier： 用户操作符，用作记录是谁，同时也应用在event数据中 properties：描述用户的更多信息。有些信息是用户直接提供的，如注册或首次交易时提供的email或邮寄地址。有些是更新的信息，如用户积累的购买次数或最近购买日期。 Event和People表都拥有一个灵活的结构。所有的事件记录都包括一个时间戳、用户标识符以及事件名称。所有的用户记录也包括用户标识符，可以用来与该用户的事件数据进行join查询。除此之外，剩下的数据结构就是所谓的属性（Properties），对于每一条不同的数据，它的结构可能都是不同的。大多数时候，对于同一个事件类型（指事件名称相同的数据），属性基本上固定的结构或者说是高度重合的。但是，对于不同的事件类型，属性中重复的内容很少。 Event记录是不可以修改的：它们都是一次性发送过来，再也不会发生改变。唯一的例外是为了符合GDPR的要求，如果用户请求删除它们的数据，那么我们需要将其相关数据进行删除操作。People的记录数据是可以修改的：他们包含了用户最近的信息，可能随时会发生改变。 以用户为中心的产品Mixpanel的特点是分析用户的行为：在使用产品时，用户最喜欢做什么以及最不喜欢做什么？以用户为中心的数据模型使得这些特点可以方便地让客户去使用，同时对我们来说，实现起来也比较高效。 洞察：洞察报告可以根据事件和用户的属性数据，进行任意维度的切分。如果用户标识符同时存在于事件和用户记录中，那么就可以进行join查询；在报表的UI中，用户属性可以作为事件的属性进行显示并使用。此外，通过去用户标识符进行去重的统计，可以用来计算常见的指标：日活（DAU）。 漏斗：漏斗报表确定了用户经过一系列事件操作的转化率。举一个电子商务的例子，我们可以定义一个漏斗，它包括“查看商品”，“添加到购物车”，“购买商品”一系列事件操作，从漏斗中可以看到通过每个步骤的用户情况。与洞察功能类型，漏斗功能也支持通过事件和用户的属性进行过滤与分群。漏斗的需求并不是超前的，而应该早就存在的。 留存：留存报表用来分析用户的事件序列，用来判断产品对于用户的黏性。留存报表将用户按照他们首先触发事件的时间进行分组统计，然后再对其在时间窗口内触发另一个事件进行汇总统计用户数。留存同样可以按照属性进行过滤和分群操作。 消息：这里的消息是指通过Email或移动App的消息推送，将消息发送给某些用户。用户群可以是所有用户，也可以是根据数据属性或事件过滤的用户群。连接事件数据和用户数据的用户标识符，就包括email。 请注意，用户标识符对于接下来的内容非常重要，它使得Mixpanel可以根据用户对事件分组。 用户标识符的管理对用户标识符进行管理，可以保证识别出同一个用户生成的event数据和people数据。大多数时候，用户标识符是足以用来识别一个用户的所有事件数据的。准确地识别每一个事件的用户对于以用户为中心的数据分析来说，是非常重要的。但是，匿名用户和一个用户使用多台设备的情况，会让情况变得非常复杂。更有甚者，同一个用户有多个用户标识符。 匿名用户：单个用户可能拥有多个用户标识符，例如，在注册之前他们在匿名状态下，执行了一些操作。在注册之前，每个用户都会有一个随机生成的hash值作为用户标识符。当他们注册之后，会选择一个不同的用户标识符，如帐号、email地址等。例如，在图2中，用户”qrt-123”，在后面会被标注为“Janet”。我们需要识别出“qrt-123”在8:02的事件数据和“Janet”在8:10的事件数据，都属于同一个用户。 多设备：一个用户首先在笔记本上识别为“qrt-123”，登录后被识别为“Janet”。而在她的手机上，开始被识别为“sdr-234”，随后被识别为“Janet”。那么我们就需要把“qrt-123”，“sdr-234”以及“Janet”均识别为同一个用户。 同一个用户的不同用户标识符必须进行整合，以便正确的进行Mixpanel的相关功能计算。例如，为了计算日活DAU，每一个用户必须仅使用一个用户标识符。如果一个用户有多个用户标识符，那么DAU的数据就会虚增。为了计算漏斗，必须追溯一个用户在整个时间段内的所有事件流。例如，一个购买流程开始于手机上的浏览，结束于笔记本电脑上的信用卡支付。 Mixpanel利用用户别名Alias，解决了用户标识符管理的问题。用户别名作为用户标识符，在event和people数据记录中被发送上来，但是在数据摄取和存储的时候可以被不同的用户标识符替换。在上面的例子中，“Janet”和“sdr-234”都变成了“qrt-123”的别名。在Mixpanel存储的数据中，包括相同用户的所有的event和people数据都含有相同的用户标识符。 摄取（Ingestion）Mixpanel每年从客户方接收超过8万亿条数据。让我们跟踪了解一下一个event数据在系统内的生命周期是怎样的： 用户设备发送event数据到https://api.mixpanel.com/track 请求被我们的DNS路由到全球分布的机器上 验证event数据，并将其推入消息队列中 一个ETL处理进程运行在中心Google Cloud区域，从消息队列中消息event数据，执行数据检验，别名识别以及将记录路由到存储系统 我们的存储系统摄取event数据，快速将其持久化成文件，并在Google的Persistent Disk环境下进行复制与加密。在这个时候，数据就可以被查询到了。 经过一段时间，一批event数据将被索引成一个查询更高效、列式存储的格式，并上传到Google Cloud存储中。 99%的记录从抵达服务器到可被查询，花费时间不超过1分钟。这就是为什么Mixpanel可以提供实时分析的原因。 ETL处理程序还会将每条记录以kv形式存储用于实时报表。实时报表提供了一个实时查询数据记录，方便调试以及理解数据的功能。 存储（Storage）Mixpanel的数据存储是一个分布式的，以用户为中心的基于事件的数据库，用于数十亿级事件数据的交互式分析。 列式存储Mixpanel的数据原本是行式的：一个json对象描述了event或people记录的数据。但是列式存储的布局变成了分析型数据存储的标准。分析式的查询一般仅针对每条记录中的几列进行聚合的操作。列式存储允许查询仅仅访问需要的列，对于单列也可以进行更快的扫描。 在2015年，我们为Mixpanel开发一个新的列式存储系统。主要的原因是考虑功能性以及性能。 功能性：Mixpanel的数据格式比较灵活，没有固定的schema。我们需要处理一些没有申明的属性，有可能每条数据都发生变化。大多数的数据存储对schema的修改要求都很严苛。 性能：Mixpanel的数据和查询都是以用户为中心的。为了控制数据的布局与数据分布，我们对数据和查询进行了优化，通过了解数据布局，降低查询计划的消耗，减少执行步骤，减少网络数据传输，以便达到更快的查询。 数据在分布式的环境下，按照userid进行分片存储。因此，单个用户所有的event数据都将保存在同一台机器上。 查询过程能够利用每个用户在同一台机器上的所有数据。例如，可以在每台服务器上对DAU进行独立的计算。类似的，漏斗的计算可以在一台机器上将某一个用户的所有历史event数据进行计算。 列式存储对数据进行10倍的压缩，同时允许查询仅访问需要的列，这样就可以更迅速和有效的得到查询结果。当我们将存储转为列式之后，查询的等待时间提升了将近5倍，CPU使用率降低了10倍。结果我只需要更少的硬件就可以达到相同的查询负载要求。我们也有足够的查询能力去添加新的查询功能，比如通知和自动分群。 列式存储数据格式 接下来，我们介绍一下列式存储的数据格式。对于Mixpanel中的每一个项目，每天都会创建一个列式存储的文件。每个文件分4个部分（section），如上图所示： Header：开始和结束的时候戳，event的数量，后续section的地址以及其它的元数据 Dictionaries：3个不同的字典，分别对应属性名称、属性值以及userid Index：每个event的每个属性的位置，按event名称，property名称排序 Data（Columns）：value的数量加上所有event所有properties的实际的值 每个字典都使用LZ4压缩算法，存储在文件中。一个属性的值存储在一个数据段中，并按事件的时间戳进行排序。属性的值或者保存原始值，或者利用字典进行索引，无论哪种都对属性进行压缩处理。对重复值使用RLE，对整数使用字节打包，同时利用索引节省空间。 数据分片数据是被切分保存的，系统中数据以用户标识符作为key进行分片处理，保证了一个用户的所有数据都保存在同一台服务器上。为了能够支持灾备，我们在两个不同区域维护了多份数据的复制。为了增加可靠性，所有数据都会生成定期的快照保存在Google Cloud Storage（GCS）中。考虑到成本和扩展因素，历史数据同样会持久化在GCS中。 在数据摄取的过程中，每个区域的存储服务器都会消费所在机器上的分片数据，将他们保存为行式的存储文件，使得这些数据可以被立即查询到。同时，一个索引的进程在后端运行，将这些行式的存储文件转化为我们的列式存储格式。这样既压缩的数据，又提升了查询的性能。查询操作既可以从行式存储，也可以从列式存储中读取数据。 可扩展性与可靠性数以百计的切片数据为数据摄取和查询提供了高扩展性。我们的系统可以随着数据的增长对其进行重新分片，所以支持水平扩展。 每个切片会有多份复制，这样的话只要有一份复制在，数据就不会丢失。Mixpanel因此在处理机器升级和错误的情况下，不会造成数据的丢失以及不可用的情况发生。数据摄取与查询维持稳定运行时间达到了99.98%。 查询（Query）查询接口Mixpanel的客户可以有多种方式进行数据的查询。他们可以通过浏览器，在Mixpanel的UI上进行操作，或通过手机上Mixpanel的App，或通过调用Mixpanel提供了查询API接口。 客户可以在Mixpanle的UI上创建以及查看数据报表。每一张报表都会通过一次或多次调用查询的API获取数据，并进行可视化的展示。在界面中有许多功能强大的报表类型，如分群、漏斗、留存等报表。客户也可以通过在Mixpanel的App上操作创建以及查看指标。 最后，客户可以直接调用查询的API。有些客户通过脚本查询，定期查看指标。另一些客户将查询嵌入到其它的应用内，将数据展示给他们的用户。这些应用场景均可以通过UI查询提供支持。 查询过程为了查询的高性能、实时以及以用户为中心，Mixpanel自建了查询的技术栈。Distributed Query Server（DQS）负责接收查询请求，请求被分发到许多Local Query Servers（LQS）进行并行计算。查询同时基于历史数据以及实时获取的数据，以便提供实时的查询结果。每一个LQS将结果返回给DQS执行聚合操作，并将最终结果返回给客户。 2017年，我们基于Google的云平台对查询引擎进行了云原生的重构。其中一项就是解耦了存储层与计算层，以便可以对这两层分别进行扩展。当客户采集了更大规模的数据之后，我们的存储层可以无缝地进行扩展，保证安全可靠的存储。当客户进行海量复杂的查询时，我们使用数以千计的CPU核在几秒钟内计算TB级的数据。我们的MPP架构，结合我们对用户分析的系列优化，提供了独一无二的速度与扩展上的优势。 我们的基础设施为我们更高级的功能打下了基础，比如Messages和自动洞察。Messages就是由我们实时的能力所支撑，客户能够对数据进行及时、自动化的操作。我们的高级机器学习功能，像异常检测和自动分群等运行得非常棒，因为我们的模型每天都基于万亿级的数据进行训练。如果没有这些构成Mixapnel基础的可扩展的基础架构，想要达到这样的效果是不可能的。 安全性Mixpanel技术栈中的安全安全是Mixpanel技术栈中必须要考虑的部分，体现在以下几个方面： 逻辑数据隔离：客户所有的数据都会根据所属项目进行信息标注，而且这个信息在架构中的每一层都是有效的，从而保证了数据的请求的合法性，仅针对所属项目返回相应的数据。 数据保护：我们的生产环境与公网之间有严格限制的防火墙，而且所有客户的数据都是加密的。 审计：对于访问客户数据和生产系统的个人，有着严格的限制，必须有书面的许可。同时，所有的数据访问行为都会被定期审核，以防数据被滥用。 总结Mixpanel提供了一个快速、可扩展、可靠以及安全的产品分析平台。接下来的图表总结了Mixpanel的架构设计是如何提供速度、扩展性、可靠性和安全性的。 Mixpanel产品分析平台的架构服务超过20000家客户，包括BMW、DocuSign、US Bank和Microsoft。我们了解到他们利用我们的产品帮忙他们回答了绝大多数用户与产品的问题，所以我们对于我们系统的性能、可靠性和安全性非常重视。我们有将近三分之一的工程师负责创建这篇文章中提及的采集、存储和查询系统。同时，我们每天都在从功能和性能上对其进行优化。 Ingestion Storage Query 速度 Speed 对不同数据量的客户使用不同的消息队列 自定义分布式列式存储，基于Google Cloud Platform扩展 分布式处理，仅读取需要的列，本地数据缓存，根据切片的复制进行任务划分 扩展性 Scale 很多http服务器和消息队列。可根据需求水平扩展，增加新的服务器 许多的数据分片 数据分片的本地处理 可靠性 Reliability 全球分布式采集中心。远程复制进行容灾处理 每个数据分片至少有2份复制 查询过程能够使用任意切片的复制 安全性 Security 使用TLS 1.2，256bit AES加密 256bit数据加密 使用LTS 1.2，256bit AES加密 原文链接：https://mixpanel.com/wp-content/uploads/2018/06/System-architecture_June2018.pdf","link":"/posts/mixpanelarchitecture.html"},{"title":"R语言使用简介","text":"R 的基本介绍R 语言基于 S 语言，是一种免费的用于数据分析的语言。 R系统从概念上分为两部分： 从 CRAN上下载的基础的R 系统； 其它 R 的功能基本上是由各种不同的 package 提供实现的: base包提供 R 的基本功能； R 的基础部分包括这些 packages：utils, stats, datasets, graphics, grDevices, grid, methods, tools, parallel, compiler, splines, tcltk, stats4 其它一些推荐安装的 packages：boot, class, cluster, codetools, foreign, KernSmooth, lattice, mgcv, nlme, rpart, survival, MASS, spatial, nnet, Matrix R 的 Input 和 EvaluationR 使用**&lt;-符号作为赋值操作，=**也可以。 如x&lt;-1可以使用x或print(x)显示 x 的值。 x：自动显示 print（x）：明确指定显示 当输入一个表达式变量并回车后，变量即被 evaludated ，并返回变量的结果。 x&lt;-1:20 **:**符号表示建立一个整形的序列 R 的数据类型对象类型R的5种基本（atomic）的数据类型： character numeric（real numbers） integer complex logical（True/False） 常用的对象类型有 vector，vector 只能包含相同的数据类型，但有一个例外，就是 list，它以 vector 形式显示，但可以保存不同的数据类型。 空 vector 可以用**vector()**表示。 NumbersR 中的数字默认为numberic 类型，即双精度浮点数，如果是整型数据，需要指定 L 后缀。例如1是一个numberic 对象，而1L 则是integer。 Inf 代表无限，1/0的结果是 Inf。Inf 可以用来计算中，如1/Inf=0。 NaN代表未定义的，如0/0，也可以代表缺失的值。 Vectors建立 vector对象，可以使用 **c()**函数进行，如： x&lt;-c(0.5,0.6) ##numeric x&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) ##character x&lt;-c(TRUE,FALSE) ##logical x&lt;-c(12:23) ##integer x&lt;-c(1+0i,2-4i) ##complex 也可以用vector()初始化对象，如： x&lt;-vector(&quot;numeric&quot;,length=10) x [1] 0 0 0 0 0 0 0 0 0 0 当不同的对象类型混合在一个 vector 里的时候，会发生coercion（胁迫），将 vector 内的对象转换成相同类型的对象。 y=c(1.7,&quot;a&quot;) y [1] &quot;1.7&quot; &quot;a&quot; 可以看到，numeric 类型的1.7被强制转换成了”1.7”。这种是自动的转换数据类型。 还可以指定明确的转换类型，使用*as.**来进行转换： x=0:6 class(x) 结果： [1] &quot;integer&quot; as.logical(x) 结果： [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE 对于无意义的指定转换，结果为NA： x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) [1]NA NA NA Matrics矩阵是有维度属性的vector，矩阵 matrics 的 dimension 属性是由一个长度为2的整数vector(nrow,ncol)组成。 创建 matrics 的几种方法： m = matrix(nrow=2,ncol=3) [,1] [,2] [,3] [1,] NA NA NA [2,] NA NA NA m = matrix(1:6,nrow = 2, ncol = 3) [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 m = 1:10 dim(m) = c(2,5) [,1] [,2] [,3] [,4] [,5] [1,] 1 3 5 7 9 [2,] 2 4 6 8 10 还可以使用 cbind()和rbind()把 vector 拼成一个 matrics： x = 1:3 y = 10:12 cbind(x,y) x y [1,] 1 10 [2,] 2 11 [3,] 3 12 rbind(x,y) [,1] [,2] [,3] x 1 2 3 y 10 11 12 FactorsFactors用来展现分类的数据，它可以是有顺序的也可以无序。可以把他们看作是一个整数的向量，其中每个整数有一个标签。（类似枚举类型） x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) [1] yes yes no yes no table(x) unclass(x) Factors中的元素顺序可以通过 level 来设定， x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)) Missing ValuesNA 和 NAN 用来代表未定义的数学操作 is.na()判断是否为 NAis.nan()判断是否为 NaN NA 值也有一个类型，所以存在integer的 NA，character 的 NA 等NaN 也是 NA，但 NA 不是 NaN x&lt;-c(1,2,NA,10,3) is.na(x) [1] FALSE FALSE TRUE FALSE FALSE is.nan(x) [1] FALSE FALSE FALSE FALSE FALSE x&lt;-c(1,2,NaN,NA,4) is.na(x) [1] FALSE FALSE TRUE TRUE FALSE is.nan(x) [1] FALSE FALSE TRUE FALSE FALSE Data FramesData Frames用来存储表格数据(tabular data) 通常，data frames 是由read.table()或read.csv()创建的。可以使用data.matrix()转换为 matrix x &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F)) &gt;x foo bar 1 1 TRUE 2 2 TRUE 3 3 FALSE 4 4 FALSE nrow(x) [1] 4 ncol(x) [1] 2 Names可以对R 的对象进行命名操作 x&lt;-1:3 ## 针对 vector names(x) NULL names(x) &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;norf&quot;) x foo bar norf 1 2 3 names(x) [1] &quot;foo&quot; &quot;bar&quot; &quot;norf&quot; x&lt;-list(a=1,b=2,c=3) ## 针对 list m &lt;- matrix(1:4, nrow = 2, ncol = 2) ##针对 matrices dimnames(m) &lt;- list(c(&quot;a&quot;, &quot;b&quot;), c(&quot;c&quot;, &quot;d&quot;)) R读写数据 read.table, read.csv用来读取表格数据，对应write.table readLines读取文本文件的行,对应writeLines source 读取 R 的 code 文件，对应dump dget, 读取 R 文件，对应dput load, 读取workspaces文件，对应save unserialize, 读取R对象，对应serialize read.tableread.table是最常用的读取数据的方法，有以下的参数： file：文件名 header：logical值，是否有 header 行 sep：列分隔字符 colClasses： 一个character向量，说明数据集中每一列的类型 nrows：行数 comment.char：注释字符 skip：从文件头跳过的行数 stringsAsFactors：是否把字符变量转化为 factors 读取方法： data &lt;- read.table(&quot;foo.txt&quot;) 在读取过程中，R 会： 会跳过所有以#开头的行 会显示多少行，分配了多少内存 说明每一列的变量类型 read.csv()也是一种 read.table()，只不过默认以，为分隔符 对于大数据，有一些方法可以提高读取的速度： 设置comment.char = “”，如果没有注释行 使用 colClasses参数，指定每一列的类型，这样读取速度可以提高一倍。如所有的列都是 numeric，可以设置 colClasses=”numeric”。 另一个 dirty 方法，可以解决不同列类型的表: initial &lt;- read.table(&quot;datatable.txt&quot;, nrows = 100) classes &lt;- sapply(initial, class) tabAll &lt;- read.table(&quot;datatable.txt&quot;,colClasses = classes) 读取其它文件file：读取文件gzfile：读取 gz 文件bzfile：读取 bz 文件url：读取 url con &lt;- file(&quot;foo.txt&quot;, &quot;r&quot;) data &lt;- read.csv(con) close(con) 与 data &lt;- read.csv(&quot;foo.txt&quot;) 相同 Subsetting 子集[]：返回与原始数据相同的类，可一次读取多个值[[]]：从 list 或 data frame 中读取数据$：用 name 方法从 list或 data frame 中读取数据 三中读取值的方式的不同： x &lt;- list(foo = 1:4, bar = 0.6) x[1] $foo [1]1234 x[[1]] [1]1234 x$bar [1] 0.6 x[[&quot;bar&quot;]] [1] 0.6 x[&quot;bar&quot;] $bar [1] 0.6 还可以用 vector 取值： x &lt;- list(foo = 1:4, bar = 0.6, baz = &quot;hello&quot;) x[c(1, 3)] $foo [1]1234 $baz [1] &quot;hello&quot; [[索引值可以为变量，而$只能使用常量名称： x &lt;- list(foo = 1:4, bar = 0.6, baz = &quot;hello&quot;) name &lt;- &quot;foo&quot; x[[name]] [1]1234 x$name NULL x$foo [1] 1 2 3 4 The [[ can take an integer sequence. x &lt;- list(a = list(10, 12, 14), b = c(3.14, 2.81)) x[[c(1, 3)]] [1] 14 x[[1]][[3]] [1] 14 x[[c(2, 1)]] [1] 3.14 Matrix使用[i,j]形式取值： x &lt;- matrix(1:6, 2, 3) x[1, 2] [1] 3 行或列可以缺失，就是取整列或整行： x[1,] [1]135 x[,2] [1]34 当对 matrix 取单一元素值的时候，加上drop = FALSE，可以使返回值从 vector 变成 matrix： x &lt;- matrix(1:6, 2, 3) x[1, 2] [1] 3 x[1, 2, drop = FALSE] [,1] [1,] 3 取整列的时候也是一样，drop=FALSE 可以把结果变成 matrix： x &lt;- matrix(1:6, 2, 3) x[1, , drop = FALSE] [,1] [,2] [,3] [1,] 1 3 5 Partial Matching 部分匹配： [[和$取值时允许参数部分匹配，如： x &lt;- list(aardvark = 1:5) x$a [1]12345 x[[&quot;a&quot;]] NULL x[[&quot;a&quot;, exact = FALSE]] [1]12345 删除 NA 值的方法： x&lt;-c(1,2,NA,4,NA,5) bad &lt;- is.na(x) x[!bad] [1]1245 complete.cases(x, y) vector 的操作： x&lt;-1:4;y&lt;-6:9 x+y [1]791113 x&gt;2 [1] FALSE FALSE TRUE TRUE x &lt;- matrix(1:4, 2, 2); y &lt;- matrix(rep(10, 4), 2, 2) x * y [,1] [,2] [1,] 10 30 [2,] 20 40 R 语言的控制结构条件if-else 结构 if(&lt;condition&gt;) { ## do something }else{ ## do something else } if(&lt;condition1&gt;) { ## do something } else if(&lt;condition2&gt;) { ## do something different }else{ ## do something different } 循环for 循环 x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) for(i in 1:4) { print(x[i]) } for(i in seq_along(x)) { print(x[i]) } for(letter in x) { print(letter) } while 循环： count &lt;- 0 while(count &lt; 10) { print(count) count &lt;- count + 1 } repeat 循环： x0&lt;-1 tol &lt;- 1e-8 repeat { x1 &lt;- computeEstimate() if(abs(x1 - x0) &lt; tol) { break }else{ x0&lt;-x1 } } next 用于跳过本次循环，开始下一个循环；return 是直接返回 函数 function格式为： f &lt;- function(&lt;arguments&gt;) { ## Do something interesting } 函数的参数可以设定默认值 参数具有 lazy evaluation 的特性，如果某个参数在函数中没有用到，那调用时可以不传入该参数，函数不会报错。 …参数一般用来传递给内部调用的其它函数 Scoping Rules符号与值的绑定R把一个符号绑定到一个值上，是通过一系列的 environments找到合适的值。当在 shell 下使用一个变量时，大概的过程是： 查找全局的 environment， 是否有值匹配该变量符号； 在 search list 中，查找每个 package 的 namespace search()可以查找当前的 search list 情况： global environment或user workspace通常是 search list 的第一个元素，base包总是最后一个元素。 当用户使用 library 加载时，该 package 的 namespace 会在 search list 的第2位上，其它的元素会相应后移。 R 对于函数和非函数有不同的 namespace，所以会同时有一个叫 c 的对象和叫 c 的函数。 Scoping Rulesscoping rules决定了在函数中，一个值如何与 free variable建立关联。 R 使用lexical scoping和static scoping，一个可选的方案dynamic scoping。 Scoping Rules 决定了 R如何使用search list为绑定符号和值。 Lexical Scoping如下面的函数： f &lt;- function(x, y) { x^2+y/z } 变量 z 在函数参数中未定义，但是直接使用了，这种变量称为free variable。Scoping Rules定义了这种 free variable 是如何赋值的 Lexical scoping的意思是：the values of free variables are searched for in the environment in which the function was defined. environment 是一组键值对的组合，a collection of (symbol, value) pairs每个 environment 有它的父 environment，一个environment 可能有多个子 environment；没有父 environment 的 environment，是一个空的 environmentfunction+environment = a closure or function closure 查找 free variable 的值的过程： If the value of a symbol is not found in the environment in which a function was defined, then thesearch is continued in the parent environment. The search continues down the sequence of parent environments until we hit the top-level environment; this usually the global environment (workspace) or the namespace of a package. After the top-level environment, the search continues down the search list until we hit the empty environment. If a value for a given symbol cannot be found once the empty environment is arrived at, then an error is thrown. R Scoping RulesWhen a function is defined in the global environment and is subsequently called from the global environment, then the defining environment and the calling environment are the same. This can sometimes give the appearance of dynamic scoping. In R, all objects must be stored in memory All functions must carry a pointer to their respective defining environments, which could be anywhere In S-PLUS, free variables are always looked up in the global workspace, so everything can be stored on the disk because the “defining environment” of all functions is the same. Lexical scoping summary Objective functions can be “built” which contain all of the necessary data for evaluating the function No need to carry around long argument lists — useful for interactive and exploratory work. Code can be simplified and cleand up Coding Standards for R Always use text files / text editor Indent your code Limit the width of your code (80 columns?) Limit the length of individual functions Date and Time日期用 Date 类表示，它的内部是记录自从1970-1-1开始的天数 时间用POSIXct或者POSIXlt类表示，内部记录的是以从1970-1-1开始的秒数 x &lt;- as.Date(&quot;1970-01-01&quot;) POSIXct is just a very large integer under the hood; it use a useful class when you want to store times in something like a data frame POSIXlt is a list underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month Times can be coerced from a character string using the as.POSIXlt or as.POSIXct function. x &lt;- Sys.time() [1] &quot;2013-01-24 22:04:14 EST&quot; p &lt;- as.POSIXlt(x) names(unclass(p)) [1] &quot;sec&quot; &quot;min&quot; &quot;hour&quot; &quot;mday&quot; &quot;mon&quot; [6] &quot;year&quot; &quot;wday&quot; &quot;yday&quot; &quot;isdst&quot; p$sec [1] 14.34 strptime函数用来转换日期格式： datestring &lt;- c(&quot;January 10, 2012 10:40&quot;, &quot;December 9, 2011 9:10&quot;) x &lt;- strptime(datestring, &quot;%B %d, %Y %H:%M&quot;) x","link":"/posts/Rlanguage.html"},{"title":"读书笔记-B端产品经理入门","text":"B端产品整体建设流程产品总体建设流程大体上分为业务问题诊断、设计解决方案（包括整体与细节方案）、执行并优化解决方案（分为设计技术方案、实施、迭代）三大阶段。 业务调研 业务调研是在产品设计之前要开展的非常重要的准备工作，在这个阶段，产品经理要全面研究并理解业务的现状和规划，挖掘并总结业务问题。 在业务调研阶段，产品经理需要尽可能地用各种手段和工具收集业务关键信息，通过对业务负责人、一线业务人员等角色进行访谈，获取全面的信息；另外，可以邀请技术负责人一起参与业务调研，确保对业务的理解是一致的。通过业务调研找到关键业务问题，这是设计产品解决方案的核心前提。 整体方案设计 整体方案设计讲究体系性、结构性。基于对业务现状与发展方向的理解，产品经理需要和架构师、技术负责人一起，规划产品的功能范围、定位，以及和公司现有产品体系如何融合，形成对后续细节设计有指导意义的整体方案，包含以下方面。 核心业务流程：梳理整个业务主干流程，并确定其中哪些环节需要由该产品实现线上化。 产品定位：明确该产品有哪些子系统，分别支持哪些业务流程和业务版块。 应用架构：考虑该产品和公司现有系统的融合关系。 功能模块：基于对业务的理解，抽象出该产品的具体功能模块。 演进蓝图：根据业务优先级与发展策略，制订实现各功能模块的计划和节奏。 细节方案设计 数据建模，也叫业务建模或领域建模，是细节方案设计中最重要的环节，是保证产品设计严谨可行的关键工作。只有基于对业务的理解，抽象出合理且灵活的数据模型，才能设计出有持续灵活性和扩展性的应用系统。在后续的学习中，你会慢慢理解为什么数据建模是产品细节设计成功的基石。 角色与流程设计会涉及业务团队的组织架构和岗位编制，需要产品经理与业务负责人一起讨论决定。 界面与报表是业务用户直接看到的部分，在设计时最好能提供可以体验的交互界面，让业务用户提前感受并反馈意见，减少不必要的返工。 技术方案 产品的整体方案、细节方案都设计好后，就需要技术人员做技术方案设计了，从而保证软件系统在正确的技术选型和合理的技术架构下进行编码开发工作。 项目管理与实施 B端产品往往涉及多个业务部门，需要多个业务系统的跨端配合，如何推进跨端项目？如何保证项目如期高质量交付？做好项目管理是关键：完善的项目管理机制可以保证实施环节顺利进行；相反，如果项目管理混乱，任意变更需求、扩大项目范围，就会导致项目无限延期。 运营迭代 新系统上线后，产品经理要和业务人员一起参与产品的运营迭代工作，包括宣传、推广、使用效果分析、问题和反馈意见的收集，以及持续的迭代优化。 业务调研业务调研的流程 明确调研目标：调研目标即调研的目的，有了明确的目标，工作才能朝正确的方向开展，因此这一步非常关键。具体应该如何确定调研目标， 选取调研对象：对于B端业务调研，调研对象一般包括业务高管、业务经理、一线业务人员、合作伙伴高管、合作伙伴经理、合作伙伴一线人员等。针对高管，可以了解业务战略定位、战略目标等信息；针对经理或负责人，可以了解业务的管理思路、经营思路等信息；对于一线业务人员，可以获取作业过程、操作细节等信息。确认调研方法：调研方法包括定性分析法和定量分析法，具体包括访谈、轮岗实习、问卷调研等方法。在实践中，需要结合具体情况选取合适的调研方法。 执行调研计划：如果前面的准备工作做得足够充分、细致，那么具体执行时就会相对顺利且有效。调研工作需要耐心，需要专注和投入，每天晚上结束后还要整理素材或资料，保证获取的所有信息都能被及时准确地记录下来。 总结归纳输出：业务调研的主要目的是掌握业务情况、诊断业务问题。调研结束后，要产出一份详细的调研报告，总结业务现状和问题，并确定各个问题的优先级，以便为后续的方案设计和实施路径提供决策支持。 业务调研的目的和分析框架业务调研有两个重要目的，一是梳理业务现状，二是总结业务问题。业务分析框架如下图： 战略层：战略层包括业务的战略定位和战略目标。战略是公司关于生产经营活动的顶层设计，决定了公司的走向和资源的聚焦点；战略决策会对公司的经营发展甚至存亡产生影响。公司战略是管理学中很重要的研究范围，制订战略需要研究市场、经济、环境等方方面面因素。业务调研首先要明确该项业务在公司中的战略定位，因为战略定位会决定具体的经营策略，并最终影响产品方案设计。理解战略定位、战略计划，可以在产品方案设计的关键点上做出正确选择。战术层：战术层是对战略层的认知进一步具象化的层级，可以从经营策略、管控模式两个方面开展分析。经营策略，通俗来讲就是做买卖的思路，包括客群定位、定价策略、营销策略、渠道管理策略、供应链管理策略等，这其中的每一个主题都涉及庞大的知识体系，产品经理需要扩充各个领域的知识，最好对这些版块都形成基本的认知，这会对工作的顺利开展有帮助。业务调研的目的之一是理解公司的经营策略，确保对产品的定位。管控模式是指集团对下属企业的集权、分权管理策略，也可以指总公司对分公司的运营管理策略。不同的管控模式所需的配套管理系统当然大不相同，因此这也是B端业务调研需要弄清楚的事项。执行层：执行层包含比战术层更具体的执行策略，包括管理层和运营层两方面。 管理层：在明确了经营策略、管控模式等基本方针后，需要梳理组织架构关系，以便对组织架构做出优化；还需要明确人力资源计划，从管理角度保障上层策略的落地。这是业务调研的又一个目标 运营层：接下来就是明确具体业务流程、绩效管理、风险控制等更加细节的规则，以便在实际运营中推进上层策略的落地。其中，梳理具体业务流程[2]是理解并掌握业务的重要途径，同时也能理清楚人员、岗位、职责的关系。流程合理会让管理和运营提效、风险可控，这也是B端产品的重要业务价值之一；流程不合理，会导致成本增加、服务质量降低。还要留意一点，流程规范化是一把双刃剑，一方面可以规范管理，另一方面可能导致僵化死板，在梳理、设计互联网公司的业务流程时要把握好尺度。 业务调研的方法业务调研的常用方法包括深度访谈、轮岗实习、调研问卷、数据分析、行业研究。 深度访谈 ：深度访谈是了解业务全貌的最快的手段。通过一对一面谈，可以直面问题，迅速获得答案。在做深度访谈时，产品经理就像一个记者，要在有限的访谈时间内，赢得访谈对象的信任、好感，获得有价值的信息。深度访谈有以下注意事项：提前准备好访谈思路、大纲、问题，选好访谈对象，想清楚通过访谈想要了解什么。如果事前没有做好准备，就好比记者采访前没有准备好提纲，必然会导致对话内容发散、混乱，无法收集到足够多的有效信息。典型的访谈大纲模板如图所示： 从高级别人员开始访谈：从高级别人员开始访谈工作，按照从概览到局部、从全局到细节的顺序研究业务，更容易把握整体调研工作的脉络和节奏。如果一开始就陷入细节的汪洋大海，会导致抓不住关键问题。提前研究访谈对象：访谈前要从各种渠道了解访谈对象的背景，尤其针对高级别访谈对象，了解得越充分、细致越好。比如，有些访谈对象可能在项目中是利益受损方，如果提前不知道这个情况，可能会得到很多干扰信息，对决策和判断产生影响。和访谈对象保持联系：访谈结束后，最好和访谈对象建立长期联系，尤其是一线业务人员。人和人面对面聊过后，会产生基本的信任感和好感，要借助访谈的机会，拉近和业务人员的距离。如果后续项目中遇到问题，想获取最真实的一线反馈，可以联系之前的访谈对象，寻求帮助。 轮岗实习：产品经理深入一线，直接体验一线业务人员的具体工作，这是深入了解业务的最好方法。做产品经理，最忌讳的就是凭自己的主观感觉进行设计，脱离实际。如何准确挖掘客户的真实需求？要么不断地和客户沟通、确认，要么直接和客户一起工作，看看到底遇到了什么问题。深入一线是产品经理有别于传统需求分析师的重要特征之一。如果不能深入一线，而只是被动地接受需求，产品经理的价值就会大打折扣，产品经理的成就感和积极性也会越来越弱。只有投身于一线，才能深刻地理解业务，做出正确的决策。产品经理要当一个冲在前线的人，而不是在后方拍脑袋的人。 调研问卷 ：线上的调研问卷是比较灵活的调研手段，既可以进行定性分析，也可以进行定量分析，并且很容易推广。问卷的内容设计一定要谨慎，因为一旦问卷发出，就无法修改问题了，如果辛辛苦苦收回了大量反馈，却发现当初的问题设计不合理，是多么让人崩溃的事情。设计调研问卷时要注意以下几点。 激励用户完成填写：问卷调研首先要确保能够回收足够多的、有效的反馈结果。如果问卷冗长、乏味，用户填写到一半很可能就离开了，因此要控制问卷的长度。在问卷的开头部分，最好告知问卷设计的目的、预计占用的时间，以便填写者有大概的心理预期。最好能带一些活动礼物，提高大家参与的积极性。 控制好开放式和封闭式问题：问卷中的开放式问题和封闭式问题的比例要合适。一般来讲，建议大部分使用封闭式选择题，以便获取定量分析的数据支撑。在问卷结尾可以留一到两个开放式问题，以保证调研对象可以自由表达想法。如果开放式问题超过2个，你需要谨慎地思考每个开放式问题的意义是什么，是否必须采用开放式。毕竟很少有人愿意花时间填写大段的文字。 避免诱导性问题：在问卷设计中，要避免诱导式的提问，例如“我们要做一个更好的个人管理功能，您会使用吗？”而要尽量采用中性描述，也尽量不要设置非此即彼的问题，例如“您是否喜欢我们的产品呢？”可以提供多个描述主观感受的选项供调研对象选择。注意，选项要采用平均切分主观感受的描述，例如可以采用“非常喜欢”“喜欢”“一般”“不喜欢”“非常不喜欢”这样的设计，而不能采用“非常喜欢”“较为喜欢”“一般喜欢”“喜欢”“不喜欢”这样的设计，因为后者提供的五个选项中有四个都是“积极的”回应，显然有失公正性。 *数据分析** ：调研时，有必要掌握业务的关键过程指标和结果指标。对于分销业务来说，过程指标包括新客户开户时长、订单处理时长、分拣配送时长、销售拜访量、新销售线索进量、销售线索转化率等；结果指标包括订单量、客单价、收入、成本、利润率等。产品经理要像业务经理那样关心业务运行的各项数据，这样才能了解业务现状，并进行业务诊断” *行业研究** 研究针对业务相关领域的经典管理案例：尽管互联网创新灵活，有很多独特的业务模式，但现代企业经营管理与业务运营的本质并没有变，总可以找到模式类似的经典管理案例进行分析参考，例如供应链管理、渠道管理、定价策略，不论是理论还是实操知识，都可以在网上获取大量参考资料。 研究市面上同类业务的商业软件特点：目前市面上大多数管理软件都有可以免费试用的SaaS版本，或具备丰富的应用案例资料。 整体方案设计核心业务流程从核心业务流程切入产品设计，是开展整个设计工作的非常好的起点。核心业务流程代表业务的主干脉络，需要思考业务的各个参与方、涉及的系统。 产品定位产品定位是对产品概要性的总结和陈述，简明扼要地描述产品对业务的支持范围，或总体的功能目标。产品定位要说清楚产品针对谁提供什么支持。 应用架构设计所谓应用架构，是指公司所有产品和系统的整体结构和布局，在设计一套新系统时，必须考虑如何和公司现有系统架构融合，不同系统的模块之间如何衔接。这项工作复杂度较高，不仅需要有丰富的架构经验，而且需要深刻理解业务特点和可能的演进方向，还要熟悉公司目前的系统架构，这样才能快速提炼出相关问题。一般由产品负责人和公司的架构师甚至CTO共同讨论确定。 功能模块设计明确了应用架构，以及需要新建或改造的系统之后，我们需要进一步细化，为每个系统设计功能模块。这个系统应用于哪些业务场景？用户可能在系统中做的操作有哪些？通过思考这些问题来抽象出需要具备的功能模块。产品经理设计的功能模块代表了其对业务本质诉求的理解和提炼，蕴含了他对业务、系统未来发展的期望。 我们常说，系统建设要有规划、有节奏，实际上功能模块图就是一幅完整的规划蓝图，能体现出系统的一二级导航菜单结构，是系统的骨架。结合业务需求实现的每一个具体功能，都是在对骨架不断地填充血肉，让它更真实、更立体、更丰富。 演进蓝图设计通过绘制系统的功能模块图，可以明确业务和系统的规划脉络。将能想到的功能集合都列出来，这是一个做加法的过程。但是我们不可能一次实现全部功能，而要根据业务优先级，拆分成几期来完成，所以接下来需要做减法：确认产品的功能规划与实现节奏，就是常说的演进蓝图（Roadmap）。 细节方案设计业务数据建模业务数据建模也叫实体建模、领域建模，或业务对象建模，是指针对业务特点，归纳并设计对应的底层数据模型的过程。B端产品进行细节设计的常见流程是，首先构建业务数据模型，然后基于流程确定页面流转图，再着手每个页面的具体设计，同时提前规划好系统用户角色，最后完成权限设计。 业务调整的灵活性取决于软件系统的灵活性，而软件系统的灵活性取决于业务数据模型的可扩展性。 业务数据建模能力体现的是设计人员对客观世界的抽象描述能力，只有对业务本质理解透彻，再结合积累的软件设计经验，才能抽象并构建出合理的业务数据模型。 流程和角色流程角色 流程合理、角色清晰是系统正确设计的前提和保障。遵循自顶向下的设计思路，我们首先设计主干流程，在这个过程中可以进一步明确系统角色及业务岗位的安排，然后基于主干流程图设计页面流转图，最终完成页面细节设计。 通过跨职能分系统流程图，可以清晰地看出谁（操作角色）在哪儿（哪个系统）做什么（完成什么工作）。无论是大型系统设计，还是某个具体需求的设计，都应该绘制流程图来帮助自己梳理业务、理清思路。 页面流转 梳理完业务流程和角色，我们进行下一步的页面流转图设计。对于系统设计来讲，业务流程图依然属于比较粗粒度的概要性设计，如何将它与软件产品的页面设计对应起来呢？绘制页面流转图是一个很好的衔接方式。 页面流转图描述的是，用户完成某项工作需要访问的页面及页面跳转顺序。绘制页面流转图可以帮设计人员审视、思考系统中的页面设计方案，包括系统中总共需要哪些页面，哪些页面可以重复使用，哪些页面需要定制化开发。一般来讲，我们绘制页面流转图时，都是针对某个单一角色绘制某个特定场景下的页面访问和跳转逻辑，从用户的视角来梳理一遍所有相关页面，每到一个新页面时，都要思考：需要新做一个页面，还是可以复用原有页面？最终整理出系统涉及的所有页面的初稿。 界面设计在团队分工明确、人力储备充足的情况下，在开发一套全新的B端业务系统时，界面设计的流程一般如下： 产品经理绘制线框图原型，表达软件中每个页面的设计需求。 UE设计师协助产品经理完善交互体验，并制作交互原型。 UI设计师基于交互原型进行美工设计，生成切图文件。 前端工程师拿到切图文件，进行前端开发，包括实现交互、动效等 尼尔森十大可用性原则 交互设计领域有丰富的理论沉淀，最著名和经典的理论当属人机交互大师雅各布·尼尔森（Jakob Nielsen）博士在1995提出的尼尔森十大可用性原则（ Jakob Nielsen’s Ten Usability Heuristics ），该理论是针对PC端交互设计提出的，但同时也适用于移动端交互设计。我们将结合具体案例详细阐述这十条指导原则，产品经理在绘制线框图时要注意遵循这些原则。 反馈原则（Visibility of system status） 系统应该在合理的时间、用正确的方式，向用户提示或反馈目前系统在做什么、发生了什么。人机交互的基本原则是，让系统和用户之间保持良好的沟通和信息传递。系统要告知用户发生了什么，预期是什么，如果系统不能及时向用户反馈合适的信息，用户必然会感到失控和焦虑，不知道下一步要做什么。以下是遵循反馈原则的一些常见设计案例： 安装程序时显示进度条，并预估还需要多久结束。上传文件时显示进度条，并提示预估剩余时间。提交表单时，如果校验失败，则在填写有误的内容旁边提示错误原因。程序未响应时，系统会让用户选择是关闭程序还是等待程序响应 隐喻原则（Match between system and the real world） 系统要采用用户熟悉的语句、短语、符号来表达意思。遵循真实世界的认知、习惯，让信息的呈现更加自然，易于辨识和接受。在人机交互设计中，程序的沟通和表达、功能的呈现，都要用最自然的、用户容易理解的方式，避免采用计算机程序语言的表达方式。设计时要采用符合真实世界认知的方式，让用户通过联想、类比等方法轻松地理解程序想表达的含义。 回退原则（User control and freedom） 用户经常会不小心操作错误，需要有一个简单的功能，让程序迅速恢复到错误发生之前的状态。用户误操作的概率极高。对于误操作，软件系统应该尽量提供“撤销”“重做”或“反悔”的功能，让系统迅速返回错误发生之前的状态。当然，不是所有操作都是可以“反悔”的，比如，你可以撤销一笔错误的订单，但不能撤销一笔成功的转账交易。以下是遵循回退原则的常见设计案例： 编辑类软件都提供撤销功能，例如Word、美图秀秀等 点击删除或关闭按钮后，会让用户进行二次确认 电商平台允许在一定的规则下取消订单 一致原则（Consistency and standards） 同样的情景、环境下，用户进行相同的操作，结果应该一致；系统或平台的风格、体验也应该保持一致。软件设计、产品设计中有很多约定俗成的规范，虽然没有明文规定，但大家都在遵守，因为用户已经习惯了这些规范。我们在进行设计时，应该遵循惯例，并且保持系统的一致感，不要盲目地标新立异。 防错原则（Error prevention） 系统要避免错误发生，这好过出错后再给提示。进行设计时，首先要考虑如何避免错误发生，其次再考虑如何检查、校验异常。这样做一方面可以让问题更简单，另一方面可以让用户避免或减少无谓操作。 记忆原则（Recognition rather than recall） 让系统的相关信息在需要的时候显示出来，减轻用户的记忆负担。计算机应该减轻人们的记忆负担，而不是相反。例如，当切换页面时，不应该让用户记住不同页面的内容，而应该在合适的地方积极地呈现或提示之前的信息。例如，几乎所有的App和PC端的搜索引擎都会记录用户的搜索历史并呈现给用户。 灵活易用原则（Flexibility and efficiency of use） 系统的用户中，中级用户往往最多，初级和高级用户相对较少。系统应为大多数人设计，同时兼顾少数人的需求，做到灵活易用。灵活易用原则不仅是一个交互设计原则，也代表了一种软件产品设计理念：系统既要做得简单、易用，让所有中级用户用起来得心应手；也要提供必要的帮助，让刚入门的初级用户顺利上手；还需要支持灵活的个性化定制，让高级用户能够以进阶的方式使用系统，充分发挥其价值。让高级用户灵活定制的最典型的例子是各类软件和App的配置功能，基本上所有软件都会提供定制化功能，从快捷键设置，到页面布局，再到自定义参数，软件系统会尽量提供全面的个性化设置功能，来满足不同用户的使用诉求和习惯。 简约设计原则（Aesthetic and minimalist design） 对话中不应该包含无关的或没必要的信息；增加或强化一些信息就意味着弱化另一些信息。 容错原则（Help users recognize， diagnose， and recover from errors） 错误信息应该用通俗易懂的语言说明，而不是只向用户提示错误代码；提示错误信息时要给出解决建议。对于很多运行时错误或异常，计算机程序都会返回某个错误代码，但是对于用户来讲，看到这些错误代码并不明白发生了什么，所以一定要将错误代码转换成用户能看懂的语句，并告诉用户解决的建议。 帮助原则（Help and documentation） 对于一个设计良好的系统，用户往往不需要经过培训就能轻松上手使用，但是提供帮助文档依然是很有必要的。帮助信息应该易于检索，通过明确的步骤引导用户解决问题，并且不能太复杂。现在的软件产品，尤其是C端产品普遍做了良好的交互设计，可以帮助用户快速学习使用，而不用阅读、理解复杂的说明文档。然而，B端产品的复杂性比C端产品高很多，因为B端产品蕴含很多业务流程的规则，系统中的一个按钮可能代表了一个复杂的业务处理规则，如果不了解整个业务场景和处理规则，是很难理解按钮的操作含义的。因此，对于B端产品，用户进行自助服务、自助操作的难度高很多，B端产品的帮助文档依然有存在的必要。产品设计人员要尽量在前端交互上做好引导提示，对于复杂的规则和逻辑，可以考虑通过帮助文档来指导用户。” 报表设计构建分析体系 之所以设计报表，往往是因为需要针对某个业务主题或业务诉求进行监控和分析。 构建分析体系之前，首先要明确分析目的，即需要通过分析发现哪些方面的问题；然后思考该采用什么方法来识别、诊断这些问题，其中可能的困难是什么。构建分析体系必须建立在对业务的深刻、准确理解之上，并且要和一线管理团队多沟通，可能很多问题的分析框架和思路已经被一线工作者发现并有效实践了，一定要善于发掘并参考、借鉴。 定义观察指标 理清了分析框架和思路，下一步要确定观察指标，设计具备明确业务含义的指标来考量业务。一般会先从大的方面拆分出几方面的观察指标，然后考虑是否将指标进一步拆解为二级指标，甚至三级指标，从而在更精细的维度观察、分析业务，更准确地反映业务特征。 设计呈现形式 确定了观察指标后，我们要思考以什么形式呈现这些指标，以便用户能够准确、快速地理解、掌握指标以及变化特征。例如，是采用数据表格还是柱状图呢？ 跟踪指标变化 管理要用数据说话，报表数据就是诊断和决策的依据。管理人员要认真对待、分析报表中各种数字的变化、波动。如果只是走马观花地浏览报表，看不出任何问题，报表就失去了意义。作为一名管理人员，必须对数字非常敏感，能够快速地感知并解读数字背后的变化和问题，这是出色的管理人员必须具备的素质。如果指标发生了明显的波动，需要跟进分析波动的原因，分析工作可以由数据分析师完成。 跟进处理问题 分析出问题后，下一步当然是给相关部门或人员安排工作，解决问题，这也是报表设计的初衷。 权限设计软件系统的权限包含两部分： 功能权限，指各个角色可以操作的界面、按钮等，例如管理员可以进行新增、删除、修改等操作；运营人员在同样的页面上只能使用各种筛选条件查看数据，无法做更改。数据权限，指各个角色在各页面中能看到的数据范围，例如分公司管理员在订单查询页能看到分公司的所有订单，而区域主管在订单查询页只能看到所在区域的订单。 关于完整的功能权限设计，最经典的理论是1995年由计算机科学家Ravi Sandhu提出的RBAC（Role Based Access Control）模型，描述了一套用户、角色、权限组的设计理念，在业务系统设计中被广泛采用。如果产品经理需要设计功能权限管理系统或模块，就必须理解RBAC权限管理模型。 完整的RBAC模型理论称为RBAC96模型族，该模型对角色的继承关系、权限的约束关系等更复杂的话题进行了深入分析和指导。RBAC96是对计算机系统权限管理的高度抽象模型，适用于任何业务系统。如果对权限管理的理论有兴趣，可以继续深入研究RBAC96体系。 角色在页面中能查到的数据范围，叫该角色的数据权限。所谓能查到的数据范围，不是指能看到的数据字段，而是指能查出来的数据集合。例如，针对订单列表页，数据范围可能是某个城市的所有订单，也有可能是某个账户下的所有订单，也可能是某几个账户下的所有订单。 针对数据权限的控制，常见的实现方案如下。 方案一，通过组织机构树控制。该方案根据账号所在组织机构树中的节点位置，来判断能够查询的数据范围。这种方式最复杂，但最灵活，能够支持各种复杂的业务数据权限诉求。方案二，通过客户地区控制。该方案根据账号所在区域来判断允许查看的数据范围。这种方式简单、容易实现，但灵活性差，只能满足非常初级的数据权限管理诉求。 文档产品设计工作会涉及一些文档，主要包括BRD（Business Requirement Document，商业需求文档）、PRD（Product Requirement Document，产品需求文档）和MRD（Market Requirement Document，市场需求文档），三者的编写时间、受众、编写目的和重点各不相同 商业需求文档（**BRD**）的管理 在产品设计工作中，无论是研发还是产品经理，都喜欢“好需求”，所谓好需求，是指具备业务价值的需求。好需求都来自业务真实的痛点或问题，经过产品设计、开发实现后，能够帮助业务解决实际问题，带来收益和价值。 产品设计的好坏，首先取决于需求的质量。如果需求质量不高，产品设计再用心，也难以产生价值。实际上，很多需求都只是需求提出者的灵光一闪的想法，并没有经过严谨的思考。对于B端产品，尤其是业务系统，业务方一般都有需求管理团队，负责调研、整理业务需求，提交给产品经理。产品经理首先需要对需求进行判断，如果发现需求质量不高，就需要和业务方反复讨论，判断需求的真实性。 如果没有一些机制或手段，让需求提交者经过全面思考后再提交需求，则可能会造成需求泛滥，需求质量低下，进而导致产品经理需要耗费很多精力去鉴别这些需求的真实性和价值。要求需求管理团队以正式BRD的形式提交需求，可以在一定程度上提高需求的质量，并且可以作为正式备档文件留存，帮助项目组提高协作效率。 产品需求文档（**PRD**）的编写 在互联网公司，产品需求文档（PRD）由产品经理编写。不同公司、团队、项目组对PRD的要求不同，有的比较严格，有的比较宽松，甚至在有些创业团队中根本不需要PRD，在产品经理和研发人员的沟通讨论过程中，功能就开发好了。但是，随着公司规模扩大，规范的PRD管理是非常必要的，这可以让项目开展更加有序，大大方便产品经理和研发人员的沟通，让知识传播与传承更加准确有效。 编写PRD是产品经理需要掌握的一项基本功，产品经理需要在PRD中用清晰、通俗的文字将复杂、抽象的软件设计思路和方案描述清楚。 产品迭代优化需求管理B端产品的需求来源十分广泛，包括一线用户、产品运营人员、业务运营人员、业务领导等的反馈，需求内容也非常丰富，包括交互体验优化、业务调整要求、业务管理要求等，而能采集需求的手段也丰富多样，包括一对一面谈、问卷调研、轮岗实习，等等。 需求收集的要点之一是，通过各种渠道全面、迅速地收集建议，而且，无论是否采纳，都要给出反馈，例如意见是否采纳、预期的解决时间等，这样才能形成持续的良性互动。 收集到需求后，产品经理不应该简单被动地接受、执行，而要识别需求背后的真实问题、判断需求的价值，这很考验产品经理的判断能力。在日常工作中，产品经理要勤于思考，尽可能地理解业务，以提升自己的判断能力。面对需求时，产品经理可以思考以下问题，帮助自己准确、迅速地判断需求的价值： 这个需求背后的真正问题是什么？ 这个问题是否有简单快速的解法？ 这个问题的影响面有多大？如果只是个案，是否值得投入精力去研究解决？ 如果是共性问题，优先级和紧急程度如何？ 对于收集到的需求，经过初步判断、过滤后，要放入需求池进行管理跟进。 从记录在案开始，到实施上线，需求要经历完整的研发管理周期。可以通过一套项目管理软件（例如JIRA、Teambition）对需求进行管理，按照公司统一的项目管理规范来实现。如果公司对项目管理的过程没有明确的规范，或者缺少工具支撑，也可以通过Excel文件来进行需求管理。 对于需求池和迭代计划，可以对它们分开管理维护，也可以合并在一起管理维护，需要根据公司的现状和要求灵活处理。不论是合并管理还是分开管理，主要目的都是实现清晰准确的需求管理、迭代计划管理，并做到项目进度透明。 通过需求池统一评判需求优先级，管理并安排迭代计划，是产品经理最重要的日常工作之一。合理运用上述模板，可以帮助产品经理将需求和项目管理得井井有条。认真填写模板中的各项内容，可以帮自己较好地分析需求跟进情况、研发效率、工作量投入等。 如果某个需求涉及跨端或跨团队开发，则需要按照子项目将模板进一步细化，例如每个子项目要安排各自的研发负责人、产品负责人，有各自的工时、工期等，然后再填写具体字段。 所谓双周迭代，即两周完成一个迭代周期，其中，一个迭代周期是指从软件开发到上线的时间。图10-2通过甘特图的形式描述了包括两轮迭代（迭代1和迭代2）的双周迭代运作过程，其中W代表周，W1代表第1周；D代表天，D1代表第1天，以此类推。浅灰色背景是迭代1的准备阶段及执行过程，深灰色背景是迭代2的准备阶段及执行过程。 一个典型的双周迭代过程如下： 1.挑选需求并编写PRD（W1D1～W2D4） 在迭代1的开发工作启动之前，产品经理（在Scrum中叫PO，Product Owner）首先要从需求池（需求池在Scrum中叫Product Backlog，具体的需求项叫PBI，Product Backlog Item）中挑选需求，这需要产品经理和研发负责人一起沟通，根据需求复杂度和研发产能来挑选最需要满足的需求。然后，针对所选需求设计方案并编写PRD。 2.评审（W2D5） PRD编写完成后，进入迭代1启动前的评审环节，评审环节要和需求方再次确认设计方案，并且给研发人员讲解产品设计方案，评审时，可以对需求范围再次进行讨论和调整。在Scrum中，评审工作叫Sprint Planning，进入迭代计划的需求清单叫Sprint Backlog。 3.技术方案设计（W2D5～W3D1） 评审结束后，研发人员要根据PRD进行技术方案设计，有的技术方案可能需要讨论几天才能确定下来。同时，产品经理开始做迭代2的准备工作。 4.开发实施与测试（W3D2～W4D4） 技术方案确定后，正式进入迭代1的开发和测试环节，对于研发人员来说，这是最紧张的阶段，这一阶段在Scrum中叫Sprint（冲刺）。在这个阶段，产品经理和研发团队每天都要召开简短的站会（Scrum中的Daily Scrum），以同步信息，并快速澄清疑问、进行决策。 5.上线（W4D5） 集中上线是一种提升研发效率和运维效率的好方法。所谓集中上线，是指将一系列功能点打包并一次性上线，而不是每做完一个功能点就进行一次上线。迭代1的功能上线的这天，正好是迭代2的评审日，研发人员可能白天要进行迭代2的评审工作，晚上要配合运维人员上线迭代1的功能。同时产品经理最好和QA一起做线上功能验收，集中打包上线的交付物（在Scrum中叫Potentially Releasable Increment，即在一个Sprint中完成的产品增量）。在上线之前，Scrum中还会有Sprint Review Meeting，产品经理和研发人员一起再次核对功能开发情况。一个迭代结束后，Scrum流程中还有Sprint Retrospective，对迭代进行总结。 以上是常见的双周迭代的产品开发流程，在研发人员开发一个迭代的功能时，产品经理开始下一个迭代的功能设计，工作交替进行，这样能保证设计工作和开发工作无缝衔接，在一个合理的时间周期内快速实现软件产品的升级迭代。","link":"/posts/toBproductmanager.html"},{"title":"Linux Shell 常用命令","text":"记录一些常用，又不是太记得住的命令。 查找文件内容1`grep -A 1 'strstrstr' filename*` 查找所有以filename开头的文件，显示包括’strstrstr’字符串的行以及下一行 1`cat xx.log | grep 单词 | wc -l` 计算某文件中，包含某一单词的行数 删除文件名1`find ./ -name &quot;._*&quot; -type f -delete` 删除当前目录及所有子目录中以._*开头的文件 目录名1`find . -type d -name &quot;.svn&quot;|xargs rm -rf` 修改权限1`find . -type f -exec chmod 644 {} \\` 将当前目录下（包括所有子目录）所有文件权限改为644 1`find . -type d -exec chmod 755 {} \\` 将当前目录（包括所有子目录）权限改为755： 查看状态网络1`netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'` 查看TCP连接数量","link":"/posts/linuxshell.html"}],"tags":[{"name":"用户行为","slug":"用户行为","link":"/tags/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"R","slug":"R","link":"/tags/R/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"B端","slug":"B端","link":"/tags/B%E7%AB%AF/"},{"name":"产品","slug":"产品","link":"/tags/%E4%BA%A7%E5%93%81/"},{"name":"流程","slug":"流程","link":"/tags/%E6%B5%81%E7%A8%8B/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"shell","slug":"shell","link":"/tags/shell/"}],"categories":[]}